package org.data.structure;

import java.util.*;
class LinkedListDemo
{
public static void main (String[]args)
{
LinkedList < String > animals = new LinkedList <> ();

// Add elements to LinkedList
animals.add ("Dog");
animals.add ("Cat");
animals.add ("Horse");
System.out.println ("LinkedList: " + animals);

// Get the element from the linked list
String str = animals.get (1);
System.out.print ("Element at index 1: " + str);
System.out.println (" ");

//Iterator method
Iterator < String > itr = animals.iterator ();
while (itr.hasNext ())
{
System.out.println (itr.next ());
}
}
}




import java.util.*;
public class StackDemo {
public static void main(String[] args) {
Stack<Double> s = new Stack<Double>();
s.push(10.2);
s.push(50.2);
s.push(30.2);
s.push(40.2);
s.push(70.2);
s.push(9.3);
System.out.println(s);
// System.out.println(s.pop());
// System.out.println(s);
System.out.println(s.peek());
System.out.println(s);
}
}






import java.util.Stack;

class Sports
{
String name;
Sports (String na)
{
name = na;
}

String getData ()
{
return "Name : " + name;
}
}

class StackDemo
{
public static void main (String[]args)
{
Stack < Sports > stack = new Stack < Sports > ();
Sports s1 = new Sports ("Cricket");
Sports s2 = new Sports ("Football");
Sports s3 = new Sports ("Basketball");
Sports s4 = new Sports ("Table Tennis");
Sports s5 = new Sports ("Badminton");


stack.push (s1);
stack.push (s2);
stack.push (s3);
stack.push (s4);
stack.push (s5);
System.out.println ("Stack size is " + stack.size ());

stack.pop ();
stack.pop ();
stack.pop ();
stack.pop ();
stack.pop ();


// Returns the number of elements present in the stack
System.out.println ("Stack size is " + stack.size ());

// check if stack is empty
if (stack.empty ())
System.out.println ("Stack is Empty");
else
System.out.println ("Stack is not Empty");
}
}





Revese queue - Preethi

/Java implementation of the above approach
import java.util.*;
class ReverseQueue
{

//Function to return the reversed queue
static Queue<Integer> reverse(Queue<Integer> q)
{
// Size of queue
int s = q.size();

// Second queue
Queue<Integer> ans = new LinkedList<>();

for (int i = 0; i < s; i++)
{

// Get the last element to the
// front of queue
for (int j = 0; j < q.size() - 1; j++)
{
int x = q.peek();
q.remove();
q.add(x);
}

// Get the last element and
// add it to the new queue
ans.add(q.peek());
q.remove();
}
return ans;
}

//Driver Code
public static void main(String[] args)
{
Queue<Integer> q = new LinkedList<>();

// Insert elements
q.add(1);
q.add(2);
q.add(3);
q.add(4);
q.add(5);

q = reverse(q);

// Print the queue
while (!q.isEmpty())
{
System.out.print(q.peek() + " ");
q.remove();
}
}
}
